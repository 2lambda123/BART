#include <deal.II/base/utilities.h>

#include <sstream>
#include <utility>
#include <iomanip>

#include "../../include/common/problem_definition.h"

using namespace dealii;

ProblemDefinition::ProblemDefinition (ParameterHandler &prm)
:
transport_model_name(prm.get("transport model")),
aq_name(prm.get("angular quadrature name")),
discretization(prm.get("spatial discretization")),
n_group(prm.get_integer("number of groups")),
n_azi(prm.get_integer("angular quadrature order")),
is_eigen_problem(prm.get_bool("do eigenvalue calculations")),
do_nda(prm.get_bool("do NDA")),
do_print_sn_quad(prm.get_bool("do print angular quadrature info")),
have_reflective_bc(prm.get_bool("have reflective BC")),
p_order(prm.get_integer("finite element polynomial degree")),
global_refinements(prm.get_integer("uniform refinements")),
output_namebase(prm.get("output file name base"))
{
}

ProblemDefinition::~ProblemDefinition()
{
}

void ProblemDefinition::declare_parameters (ParameterHandler &prm)
{
  // our final strategy is to declare all possible entries
  // and then ignore some of them suggested by Wolfgang Bangerth
  // from Colorado State on 05-10-2017
  // The following are the basic parameters we need to define a problem
  {
    prm.declare_entry ("problem dimension", "2", Patterns::Integer(), "1D is not implemented");
    prm.declare_entry ("transport model", "ep", Patterns::Selection("ep"), "valid names such as ep");
    prm.declare_entry ("preconditioner name", "amg", Patterns::Selection("amg|parasails|bjacobi|jacobi|bssor"), "precond names");
    prm.declare_entry ("ssor factor", "1.0", Patterns::Double (), "damping factor of Block SSOR");
    prm.declare_entry ("linear solver name", "cg", Patterns::Selection("cg|gmres|bicgstab|direct"), "solers");
    prm.declare_entry ("angular quadrature name", "lsgc", Patterns::Selection ("lsgc"), "angular quadrature types. only LS-GC implemented for now.");
    prm.declare_entry ("angular quadrature order", "4", Patterns::Integer (), "Gauss-Chebyshev level-symmetric-like quadrature");
    prm.declare_entry ("number of groups", "1", Patterns::Integer (), "Number of groups in MG calculations");
    prm.declare_entry ("spatial discretization", "cfem", Patterns::Selection("dfem|cfem"), "USE DFEM or CFEM for spatial discretization");
    prm.declare_entry ("do eigenvalue calculations", "false", Patterns::Bool(), "Boolean to determine problem type");
    prm.declare_entry ("do NDA", "false", Patterns::Bool(), "Boolean to determine NDA or not");
    prm.declare_entry ("have reflective BC", "false", Patterns::Bool(), "");
    prm.declare_entry ("reflective boundary names", "", Patterns::List (Patterns::Anything ()), "must be lower cases of xmin,xmax,ymin,ymax,zmin,zmax");
    prm.declare_entry ("finite element polynomial degree", "1", Patterns::Integer(), "polynomial degree p for finite element");
    prm.declare_entry ("uniform refinements", "0", Patterns::Integer(), "number of uniform refinements desired");
    prm.declare_entry ("x, y, z max values of boundary locations", "", Patterns::List (Patterns::Double ()), "xmax, ymax, zmax of the boundaries, mins are zero");
    prm.declare_entry ("number of cells for x, y, z directions", "", Patterns::List (Patterns::Integer ()), "Geotry is hyper rectangle defined by how many cells exist per direction");
    prm.declare_entry ("number of materials", "1", Patterns::Integer (), "must be a positive integer");
    prm.declare_entry ("do print angular quadrature info", "true", Patterns::Bool(), "Boolean to determine if printing angular quadrature information");
    prm.declare_entry ("is mesh generated by deal.II", "true", Patterns::Bool(), "Boolean to determine if generating mesh in dealii or read in mesh");
    //prm.declare_entry ("use explicit reflective boundary condition or not", "true", Patterns::Bool(), "");
    prm.declare_entry ("output file name base", "solu", Patterns::Anything(), "name base of the output file");
    prm.declare_entry ("mesh file name", "mesh.msh", Patterns::Anything(), ".msh file name for read-in mesh");
  }
  // FixIt: for current deal.II code, we don't consider reading mesh
  
  // Explanation: we brute-forcely declare as many entries as possible without read-in problem-definition
  // parameters. nmat and ngrp should both be large enough s.t. when reading starts, the real setting will
  // have entry-declaration
  prm.enter_subsection ("material ID map");
  {
    prm.declare_entry ("material id file name", "mid.txt", Patterns::FileName(), "file name for material id map");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("sigma_t, group=1 to G");
  {
    for (unsigned int m=0; m<nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry (os.str (), "", Patterns::List (Patterns::Double ()), "");
    }
  }
  prm.leave_subsection ();
  
  for (unsigned int m=0; m<nmat; ++m)
  {
    std::ostringstream os;
    os << "sigma_s, material " << m + 1;
    prm.enter_subsection (os.str());
    {
      for (unsigned int gin=0; gin<ngrp; ++gin)
      {
        std::ostringstream osm;
        osm << "g_in=" << gin + 1;
        prm.declare_entry (osm.str(), "", Patterns::List(Patterns::Double()), "multigroup sigma_s");
      }
    }
    prm.leave_subsection ();
  }
  
  prm.enter_subsection ("one-group sigma_t");
  {
    prm.declare_entry ("values", "", Patterns::List(Patterns::Double()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("one-group sigma_s");
  {
    prm.declare_entry ("values", "", Patterns::List(Patterns::Double()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("one-group Q");
  {
    prm.declare_entry ("values", "", Patterns::List(Patterns::Double()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("one-group ksi");
  {
    prm.declare_entry ("values", "", Patterns::List(Patterns::Double()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("one-group nu_sigf");
  {
    prm.declare_entry ("values", "", Patterns::List(Patterns::Double()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("Q, group=1 to G");
  {
    for (unsigned int m=0; m<nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry (os.str (), "", Patterns::List (Patterns::Double ()), "");
    }
  }
  prm.leave_subsection ();
  
  // the following is for eigen problems
  prm.enter_subsection ("fissile material IDs");
  {
    prm.declare_entry ("fissile material ids", "", Patterns::List (Patterns::Integer ()), "");
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("ksi, group=1 to G");
  {
    for (unsigned int m=0; m<nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry(os.str(), "", Patterns::List(Patterns::Double()), "");
    }
  }
  prm.leave_subsection ();
  
  prm.enter_subsection ("nu_sigf, group=1 to G");
  {
    for (unsigned int m=0; m<nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry(os.str(), "", Patterns::List(Patterns::Double()), "");
    }
  }
  prm.leave_subsection ();
}

std::string ProblemDefinition::get_aq_name ()
{
  return aq_name;
}

// public member functions used to retieve parameters processed
bool ProblemDefinition::get_nda_bool ()
{
  return do_nda;
}

bool ProblemDefinition::get_print_sn_quad_bool ()
{
  return do_print_sn_quad;
}

std::string ProblemDefinition::get_transport_model ()
{
  return transport_model_name;
}

std::string ProblemDefinition::get_output_namebase ()
{
  return output_namebase;
}

unsigned int ProblemDefinition::get_n_group ()
{
  return n_group;
}

bool ProblemDefinition::get_reflective_bool ()
{
  return have_reflective_bc;
}

bool ProblemDefinition::get_eigen_problem_bool ()
{
  return is_eigen_problem;
}

unsigned int ProblemDefinition::get_fe_order ()
{
  return p_order;
}

unsigned int ProblemDefinition::get_uniform_refinement ()
{
  return global_refinements;
}

std::string ProblemDefinition::get_discretization ()
{
  return discretization;
}

