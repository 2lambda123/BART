#include <deal.II/base/utilities.h>

#include <sstream>
#include <utility>
#include <iomanip>

#include "problem_definition.h"

ProblemDefinition::ProblemDefinition ()
{
}

ProblemDefinition::~ProblemDefinition()
{
}

void ProblemDefinition::declare_parameters (dealii::ParameterHandler &prm)
{
  // our final strategy is to declare all possible entries
  // and then ignore some of them suggested by Wolfgang Bangerth
  // from Colorado State on 05-10-2017
  // The following are the basic parameters we need to define a problem
  {
    prm.declare_entry ("problem dimension", "2", dealii::Patterns::Integer(), "1D is not implemented");
    prm.declare_entry ("transport model", "none", dealii::Patterns::Selection("ep|none"), "valid names such as ep");
    prm.declare_entry ("HO linear solver name", "cg", dealii::Patterns::Selection("cg|gmres|bicgstab|direct"), "solers");
    prm.declare_entry ("HO preconditioner name", "amg", dealii::Patterns::Selection("amg|parasails|bjacobi|jacobi|bssor"), "precond names");
    prm.declare_entry ("HO ssor factor", "1.0", dealii::Patterns::Double (), "damping factor of Block SSOR for HO");
    prm.declare_entry ("NDA linear solver name", "none", dealii::Patterns::Selection("none|gmres|bicgstab|direct"), "NDA linear solers");
    prm.declare_entry ("NDA preconditioner name", "none", dealii::Patterns::Selection("none|amg|parasails|bjacobi|jacobi|bssor"), "precond names");
    prm.declare_entry ("NDA ssor factor", "1.0", dealii::Patterns::Double (), "damping factor of Block SSOR for NDA");
    prm.declare_entry ("angular quadrature name", "none", dealii::Patterns::Selection ("lsgc|none"), "angular quadrature types. only LS-GC implemented for now.");
    prm.declare_entry ("angular quadrature order", "4", dealii::Patterns::Integer (), "Gauss-Chebyshev level-symmetric-like quadrature");
    prm.declare_entry ("number of groups", "1", dealii::Patterns::Integer (), "Number of groups in MG calculations");
    prm.declare_entry ("thermal group boundary", "0", dealii::Patterns::Integer (), "group number for the first thermal group");
    prm.declare_entry ("spatial discretization", "cfem", dealii::Patterns::Selection("dfem|cfem"), "USE DFEM or CFEM for spatial discretization");
    prm.declare_entry ("do eigenvalue calculations", "false", dealii::Patterns::Bool(), "Boolean to determine problem type");
    prm.declare_entry ("do NDA", "false", dealii::Patterns::Bool(), "Boolean to determine NDA or not");
    prm.declare_entry ("have reflective BC", "false", dealii::Patterns::Bool(), "");
    prm.declare_entry ("reflective boundary names", "", dealii::Patterns::List (dealii::Patterns::Anything ()), "must be lower cases of xmin,xmax,ymin,ymax,zmin,zmax");
    prm.declare_entry ("finite element polynomial degree", "1", dealii::Patterns::Integer(), "polynomial degree p for finite element");
    prm.declare_entry ("uniform refinements", "0", dealii::Patterns::Integer(), "number of uniform refinements desired");
    prm.declare_entry ("x, y, z max values of boundary locations", "", dealii::Patterns::List (dealii::Patterns::Double ()), "xmax, ymax, zmax of the boundaries, mins are zero");
    prm.declare_entry ("number of cells for x, y, z directions", "", dealii::Patterns::List (dealii::Patterns::Integer ()), "Geotry is hyper rectangle defined by how many cells exist per direction");
    prm.declare_entry ("number of materials", "1", dealii::Patterns::Integer (), "must be a positive integer");
    prm.declare_entry ("do print angular quadrature info", "true", dealii::Patterns::Bool(), "Boolean to determine if printing angular quadrature information");
    prm.declare_entry ("is mesh generated by deal.II", "true",
                       dealii::Patterns::Bool(),
                       "Boolean to determine if generating mesh in dealii or read in mesh");
    //prm.declare_entry ("use explicit reflective boundary condition or not", "true", dealii::Patterns::Bool(), "");
    prm.declare_entry ("output file name base", "solu", dealii::Patterns::Anything(), "name base of the output file");
    prm.declare_entry ("mesh file name", "mesh.msh", dealii::Patterns::Anything(), ".msh file name for read-in mesh");
  }
  // FixIt: for current deal.II code, we don't consider reading mesh

  // Explanation: we brute-forcely declare as many entries as possible without read-in problem-definition
  // parameters. k_nmat and ngrp should both be large enough s.t. when reading starts, the real setting will
  // have entry-declaration
  prm.enter_subsection ("material ID map");
  {
    prm.declare_entry ("material id file name", "mid.txt", dealii::Patterns::FileName(), "file name for material id map");
  }
  prm.leave_subsection ();

  prm.enter_subsection ("sigma_t, group=1 to G");
  {
    for (int m=0; m<k_nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry (os.str (), "", dealii::Patterns::List (dealii::Patterns::Double ()), "");
    }
  }
  prm.leave_subsection ();

  for (int m=0; m<k_nmat; ++m)
  {
    std::ostringstream os;
    os << "sigma_s, material " << m + 1;
    prm.enter_subsection (os.str());
    {
      for (int gin=0; gin<k_ngrp; ++gin)
      {
        std::ostringstream osm;
        osm << "g_in=" << gin + 1;
        prm.declare_entry (osm.str(), "", dealii::Patterns::List(dealii::Patterns::Double()), "multigroup sigma_s");
      }
    }
    prm.leave_subsection ();
  }

  prm.enter_subsection ("one-group sigma_t");
  {
    prm.declare_entry ("values", "", dealii::Patterns::List(dealii::Patterns::Double()), "");
  }
  prm.leave_subsection ();

  prm.enter_subsection ("one-group sigma_s");
  {
    prm.declare_entry ("values", "", dealii::Patterns::List(dealii::Patterns::Double()), "");
  }
  prm.leave_subsection ();

  prm.enter_subsection ("one-group Q");
  {
    prm.declare_entry ("values", "", dealii::Patterns::List(dealii::Patterns::Double()), "");
  }
  prm.leave_subsection ();

  prm.enter_subsection ("one-group chi");
  {
    prm.declare_entry ("values", "", dealii::Patterns::List(dealii::Patterns::Double()), "");
  }
  prm.leave_subsection ();

  prm.enter_subsection ("one-group nu_sigf");
  {
    prm.declare_entry ("values", "", dealii::Patterns::List(dealii::Patterns::Double()), "");
  }
  prm.leave_subsection ();

  prm.enter_subsection ("Q, group=1 to G");
  {
    for (int m=0; m<k_nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry (os.str (), "", dealii::Patterns::List (dealii::Patterns::Double ()), "");
    }
  }
  prm.leave_subsection ();

  // the following is for eigen problems
  prm.enter_subsection ("fissile material IDs");
  {
    prm.declare_entry ("fissile material ids", "", dealii::Patterns::List (dealii::Patterns::Integer ()), "");
  }
  prm.leave_subsection ();

  prm.enter_subsection ("chi, group=1 to G");
  {
    for (int m=0; m<k_nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry(os.str(), "", dealii::Patterns::List(dealii::Patterns::Double()), "");
    }
  }
  prm.leave_subsection ();

  prm.enter_subsection ("nu_sigf, group=1 to G");
  {
    for (int m=0; m<k_nmat; ++m)
    {
      std::ostringstream os;
      os << "material " << m + 1;
      prm.declare_entry(os.str(), "", dealii::Patterns::List(dealii::Patterns::Double()), "");
    }
  }
  prm.leave_subsection ();
}
